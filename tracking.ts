const data = {
  search: {
    repositoryCount: 80,
    edges: [
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-machine-learning-service",
          name: "terraform-azure-machine-learning-service",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-data-factory",
          name: "terraform-azure-data-factory",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-aks-nsg",
          name: "terraform-azure-template-aks-nsg",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-storage-account",
          name: "terraform-azure-storage-account",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-resource-group",
          name: "terraform-azure-resource-group",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-waf-policy",
          name: "terraform-azure-waf-policy",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-virtual-machine",
          name: "terraform-azure-virtual-machine",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-postgresql-flexible-server",
          name: "terraform-azure-postgresql-flexible-server",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-utils",
          name: "terraform-azure-utils",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-app-service",
          name: "terraform-azure-app-service",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-web-app-paas",
          name: "terraform-azure-template-web-app-paas",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-sql-server",
          name: "terraform-azure-sql-server",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-event-grid-topic",
          name: "terraform-azure-event-grid-topic",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-logic-app",
          name: "terraform-azure-logic-app",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-function-app",
          name: "terraform-azure-function-app",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-container-registry",
          name: "terraform-azure-container-registry",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-mariadb",
          name: "terraform-azure-mariadb",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-mysql-server-flexible",
          name: "terraform-azure-mysql-server-flexible",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-logic-app-standard",
          name: "terraform-azure-logic-app-standard",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-service-bus",
          name: "terraform-azure-service-bus",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-application-insights",
          name: "terraform-azure-application-insights",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-databricks",
          name: "terraform-azure-databricks",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-function-app-paas",
          name: "terraform-azure-template-function-app-paas",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-cdn",
          name: "terraform-azure-cdn",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-logic-app-paas",
          name: "terraform-azure-template-logic-app-paas",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-redis",
          name: "terraform-azure-redis",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-recovery-services-vault",
          name: "terraform-azure-recovery-services-vault",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-batch-account",
          name: "terraform-azure-batch-account",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-stream-analytics",
          name: "terraform-azure-stream-analytics",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-sql-managed-instance",
          name: "terraform-azure-sql-managed-instance",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-user-assigned-identity",
          name: "terraform-azure-user-assigned-identity",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-network",
          name: "terraform-azure-template-network",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-synapse-workspace",
          name: "terraform-azure-synapse-workspace",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-signalr",
          name: "terraform-azure-signalr",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-search-service",
          name: "terraform-azure-search-service",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-qna-maker",
          name: "terraform-azure-qna-maker",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-private-link-service",
          name: "terraform-azure-private-link-service",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-postgresql",
          name: "terraform-azure-postgresql",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-notification-hub",
          name: "terraform-azure-notification-hub",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-media-services",
          name: "terraform-azure-media-services",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-mysql",
          name: "terraform-azure-mysql",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-maps",
          name: "terraform-azure-maps",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-log-analytics-workspace",
          name: "terraform-azure-log-analytics-workspace",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-virtual-machine-cluster",
          name: "terraform-azure-virtual-machine-cluster",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-iot-dps",
          name: "terraform-azure-iot-dps",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-event-hub",
          name: "terraform-azure-event-hub",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-event-grid-domain",
          name: "terraform-azure-event-grid-domain",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-container-instance",
          name: "terraform-azure-container-instance",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-cosmos-db",
          name: "terraform-azure-cosmos-db",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-bot-service",
          name: "terraform-azure-bot-service",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-data-explorer",
          name: "terraform-azure-data-explorer",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-virtual-machine-scaleset",
          name: "terraform-azure-virtual-machine-scaleset",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-analysis-services",
          name: "terraform-azure-analysis-services",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-iothub",
          name: "terraform-azure-iothub",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-automation-account",
          name: "terraform-azure-automation-account",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-app-configuration",
          name: "terraform-azure-app-configuration",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-autoscale-setting",
          name: "terraform-azure-autoscale-setting",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-app-service-plan",
          name: "terraform-azure-app-service-plan",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-key-vault",
          name: "terraform-azure-key-vault",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-load-balancer",
          name: "terraform-azure-load-balancer",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-cognitive-services",
          name: "terraform-azure-cognitive-services",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-vnet",
          name: "terraform-azure-vnet",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-application-gateway-v2",
          name: "terraform-azure-application-gateway-v2",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-private-dns",
          name: "terraform-azure-private-dns",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-network-security-group",
          name: "terraform-azure-network-security-group",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-application-security-group",
          name: "terraform-azure-application-security-group",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-event-grid-system-topic",
          name: "terraform-azure-event-grid-system-topic",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-event-grid-subscription",
          name: "terraform-azure-event-grid-subscription",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-service-principal",
          name: "terraform-azure-service-principal",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-netapp-volume",
          name: "terraform-azure-netapp-volume",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-netapp-pool",
          name: "terraform-azure-netapp-pool",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-data-factory-etl",
          name: "terraform-azure-template-data-factory-etl",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-power-bi-embedded",
          name: "terraform-azure-power-bi-embedded",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-template-app-paas",
          name: "terraform-azure-template-app-paas",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-container-app-environment",
          name: "terraform-azure-container-app-environment",
        },
      },
      {
        node: {
          url: "https://github.com/procter-gamble/terraform-azure-container-app",
          name: "terraform-azure-container-app",
        },
      },
    ],
  },
};

console.log(data.search.edges.length)

const addIssueToProject = `name: Auto Add Issues to Project

on:
  issues:
    types:
      - opened
      - labeled
      - reopened
  pull_request:
    types:
      - opened
      - labeled
      - reopened

jobs:
  add-issue-497:
    name: Add issue to project 497
    runs-on: ubuntu-latest
    steps:
      - uses: actions/add-to-project@v1.0.2
        with:
          project-url: https://github.com/orgs/procter-gamble/projects/497
          github-token: \${{ secrets.TF_GITHUB_PAT }}
          labeled: do-not-merge
          label-operator: NOT
          
  add-issue-541:
    name: Add issue to project 541
    runs-on: ubuntu-latest
    steps:
      - uses: actions/add-to-project@v1.0.2
        with:
          project-url: https://github.com/orgs/procter-gamble/projects/541
          github-token: \${{ secrets.TF_GITHUB_PAT }}
          labeled: do-not-merge
  `;

const PR = `name: PR

on: 
  pull_request:
    branches:
      - master
      - main
      

jobs:
  getacrinfo:
    runs-on:  [self-hosted,Linux, cicdframework]
    outputs:
      acruser: \${{ steps.GetACRAction.outputs.acruser }}
      acrtoken: \${{ steps.GetACRAction.outputs.acrtoken }}
    steps:
     - name: 'Login via Azure CLI'
       uses: azure/login@v1
       with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }}
     - name: Azure CLI script
       id: GetACRAction
       uses: azure/CLI@v1
       with:
        inlineScript: |
         echo acruser=$(az keyvault secret show --vault-name terratest-kv --name devacr-user --query value | tr -d '"') >> $GITHUB_OUTPUT
         echo acrtoken=$(az keyvault secret show --vault-name terratest-kv --name devacr-token --query value | tr -d '"') >> $GITHUB_OUTPUT
  
  validate:
    name: Validate
    runs-on:  [self-hosted,Linux, cicdframework]
    needs: getacrinfo       
    container:
       image: devacrrepo.azurecr.io/cicd-runner:v1
       credentials:
          username: \${{ needs.getacrinfo.outputs.acruser }}
          password: \${{ needs.getacrinfo.outputs.acrtoken }}

    steps: 
    - name: Check out code  
      uses: actions/checkout@v2
      with:
       ref: \${{ github.head_ref }}   
    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }} 
    - name: 'tfvars download'
      uses: actions/checkout@v2
      with: 
        repository: procter-gamble/terraform-terratest-metadata
        ref: main
        token: \${{ secrets.TF_GITHUB_PAT }}
        path: examples/full/vars      
    - id: terratest
      name: test 
      uses: ./examples/full/vars/utils/actions
      with:
        TF_GITHUB_USER: \${{secrets.TF_GITHUB_USER}}
        TF_GITHUB_PAT: \${{secrets.TF_GITHUB_PAT}}
        TF_CLIENT_ID: \${{secrets.TF_CLIENT_ID}}  
        TF_CLIENT_SECRET: \${{secrets.TF_CLIENT_SECRET}}
        ARM_SUBSCRIPTION_ID: \${{secrets.ARM_SUBSCRIPTION_ID}}     
    - name: Send status
      if: always()
      uses: ./examples/full/vars/utils/actions/terratest-email-action
      with:        
        JOB_NAME: "\${{ github.job }}"
        REPO_NAME: "\${{ github.repository }}"  
        JOB_STATUS: "\${{ job.status }}"
        WORKFLOW_NAME: "\${{ github.workflow }}"
        job_run_id: "\${{github.run_id}}"
        terraform_version: "\${{ steps.terratest.outputs.terraform_version }}"
        azurerm_version: "\${{ steps.terratest.outputs.azurerm_version }}"
  `;

const docs = `name: docs

on:
  push:
    branches-ignore:
    - 'main'
    - 'master'
    paths:
      - 'main.tf'
      - 'outputs.tf'
      - 'variables.tf'
jobs:
  getacrinfo:
    runs-on:  [self-hosted,Linux, cicdframework]
    outputs:
      acruser: \${{ steps.GetACRAction.outputs.acruser }}
      acrtoken: \${{ steps.GetACRAction.outputs.acrtoken }}
    steps:
     - name: 'Login via Azure CLI'
       uses: azure/login@v1
       with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }}
     - name: Azure CLI script
       id: GetACRAction
       uses: azure/CLI@v1
       with:
        inlineScript: |
         echo acruser=$(az keyvault secret show --vault-name terratest-kv --name devacr-user --query value | tr -d '"') >> $GITHUB_OUTPUT
         echo acrtoken=$(az keyvault secret show --vault-name terratest-kv --name devacr-token --query value | tr -d '"') >> $GITHUB_OUTPUT

  docs:
    name: Docs
    runs-on:  [self-hosted,Linux, cicdframework]
    needs: getacrinfo
    container:
       image: devacrrepo.azurecr.io/cicd-runner:v1
       credentials:
          username: \${{ needs.getacrinfo.outputs.acruser }}
          password: \${{ needs.getacrinfo.outputs.acrtoken }}
    steps:
    - uses: actions/checkout@v2
      with:
        repository: \${{ github.repository }}
        path: tf_doc

    - name: Update README and send it back
      run: |
        cd tf_doc
        terraform-docs -c scripts/.terraform-docs.yml . > README.md
        git add README.md
      shell: bash

    - name: Commit report
      run: |
        cd tf_doc
        if ! git diff-index --quiet HEAD --; then
           git config user.name 'root'
           git config user.email '<>'
           git commit -am "updating README using terraform-doc"
           git push
        else
           echo "no changes to make in README"
        fi
  `;

const schedule = `name: Schedule

on: 
   schedule:
       - cron: '0 0 * * 1'

jobs:
  getacrinfo:
    runs-on:  [self-hosted,Linux, cicdframework]
    outputs:
      acruser: \${{ steps.GetACRAction.outputs.acruser }}
      acrtoken: \${{ steps.GetACRAction.outputs.acrtoken }}
    steps:
     - name: 'Login via Azure CLI'
       uses: azure/login@v1
       with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }}
     - name: Azure CLI script
       id: GetACRAction
       uses: azure/CLI@v1
       with:
        inlineScript: |
         echo acruser=$(az keyvault secret show --vault-name terratest-kv --name devacr-user --query value | tr -d '"') >> $GITHUB_OUTPUT
         echo acrtoken=$(az keyvault secret show --vault-name terratest-kv --name devacr-token --query value | tr -d '"') >> $GITHUB_OUTPUT
  
  validate:
    name: Validate
    runs-on:  [self-hosted,Linux, cicdframework]
    needs: getacrinfo
    container:
       image: devacrrepo.azurecr.io/cicd-runner:v1
       credentials:
          username: \${{ needs.getacrinfo.outputs.acruser }}
          password: \${{ needs.getacrinfo.outputs.acrtoken }}
    steps: 
    - name: Check out code  
      uses: actions/checkout@v2
      with:
       ref: \${{ github.head_ref }}   
    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }} 
    - name: 'tfvars download'
      uses: actions/checkout@v2
      with: 
        repository: procter-gamble/terraform-terratest-metadata
        ref: main
        token: \${{ secrets.TF_GITHUB_PAT }}
        path: examples/full/vars    
    - id: terratest
      name: test 
      uses: ./examples/full/vars/utils/actions
      with:
        TF_GITHUB_USER: \${{secrets.TF_GITHUB_USER}}
        TF_GITHUB_PAT: \${{secrets.TF_GITHUB_PAT}}
        TF_CLIENT_ID: \${{secrets.TF_CLIENT_ID}}  
        TF_CLIENT_SECRET: \${{secrets.TF_CLIENT_SECRET}}
        ARM_SUBSCRIPTION_ID: \${{secrets.ARM_SUBSCRIPTION_ID}}     
    - name: Send status
      if: always()
      uses: ./examples/full/vars/utils/actions/terratest-email-action
      with:        
        JOB_NAME: "\${{ github.job }}"
        REPO_NAME: "\${{ github.repository }}"  
        JOB_STATUS: "\${{ job.status }}"
        WORKFLOW_NAME: "\${{ github.workflow }}"
        job_run_id: "\${{github.run_id}}"
        terraform_version: "\${{ steps.terratest.outputs.terraform_version }}"
        azurerm_version: "\${{ steps.terratest.outputs.azurerm_version }}"
  `;

const terraformUpgradeProvider = `name: terraform-upgrade-provider

on: 
  pull_request:
    branches:
       - terraform-upgrade-provider
       
jobs:
  getacrinfo:
    runs-on:  [self-hosted,Linux, cicdframework]
    outputs:
      acruser: \${{ steps.GetACRAction.outputs.acruser }}
      acrtoken: \${{ steps.GetACRAction.outputs.acrtoken }}
    steps:
     - name: 'Login via Azure CLI'
       uses: azure/login@v1
       with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }}
     - name: Azure CLI script
       id: GetACRAction
       uses: azure/CLI@v1
       with:
        inlineScript: |
         echo acruser=$(az keyvault secret show --vault-name terratest-kv --name devacr-user --query value | tr -d '"') >> $GITHUB_OUTPUT
         echo acrtoken=$(az keyvault secret show --vault-name terratest-kv --name devacr-token --query value | tr -d '"') >> $GITHUB_OUTPUT
  
  validate:
    name: Validate
    runs-on:  [self-hosted,Linux, cicdframework]
    needs: getacrinfo       
    container:
      image: devacrrepo.azurecr.io/cicd-runner:v1
      credentials:
        username: \${{ needs.getacrinfo.outputs.acruser }}
        password: \${{ needs.getacrinfo.outputs.acrtoken }}
    steps: 
    - name: Check out code  
      uses: actions/checkout@v2
      with:
       ref: \${{ github.head_ref }}   
    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }} 
    - name: 'tfvars download'
      uses: actions/checkout@v2
      with: 
          repository: procter-gamble/terraform-terratest-metadata
          ref: main
          token: \${{ secrets.TF_GITHUB_PAT }}
          path: examples/full/vars  
    - id:   terraform-upgrade-provider
      name: upgrade-provider-action-metadata
      uses: ./examples/full/vars/utils/actions/upgrade-provider
      with:
          TF_GITHUB_USER: \${{secrets.TF_GITHUB_USER}}
          TF_GITHUB_PAT: \${{secrets.TF_GITHUB_PAT}}
          TF_CLIENT_ID: \${{secrets.TF_CLIENT_ID}}  
          TF_CLIENT_SECRET: \${{secrets.TF_CLIENT_SECRET}}
          ARM_SUBSCRIPTION_ID: \${{secrets.ARM_SUBSCRIPTION_ID}}     
          TF_GITHUB_REF      : v4.6.1
    - name: send-status
      if: always()
      uses: ./examples/full/vars/utils/actions/terratest-email-action
      with:
          JOB_NAME:  \${{ github.job }}
          REPO_NAME: \${{ github.repository }}
          JOB_STATUS: "\${{ job.status }}"
          WORKFLOW_NAME: "\${{ github.workflow }}"
          job_run_id: "\${{github.run_id}}"
          terraform_version: "\${{ steps.terraform-upgrade-provider.outputs.terraform_version }}"
          azurerm_version: "\${{ steps.terraform-upgrade-provider.outputs.azurerm_version }}"
          terraformold_version: "\${{ steps.terraform-upgrade-provider.outputs.terraformold_version }}"
          azurermold_version: "\${{ steps.terraform-upgrade-provider.outputs.azurermold_version }}"
  `;

const terraformUpgradeRuntime = `name: terraform-upgrade-runtime


on:
  pull_request:
    branches:
       - terraform-upgrade-runtime

jobs:
  getacrinfo:
    runs-on:  [self-hosted,Linux, cicdframework]
    outputs:
      acruser: \${{ steps.GetACRAction.outputs.acruser }}
      acrtoken: \${{ steps.GetACRAction.outputs.acrtoken }}
    steps:
     - name: 'Login via Azure CLI'
       uses: azure/login@v1
       with: 
        creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }}
     - name: Azure CLI script
       id: GetACRAction
       uses: azure/CLI@v1
       with:
        inlineScript: |
         echo acruser=$(az keyvault secret show --vault-name terratest-kv --name devacr-user --query value | tr -d '"') >> $GITHUB_OUTPUT
         echo acrtoken=$(az keyvault secret show --vault-name terratest-kv --name devacr-token --query value | tr -d '"') >> $GITHUB_OUTPUT
  
  validate:
    name: Validate
    runs-on: [self-hosted,Linux, cicdframework] 
    needs: getacrinfo       
    container:
      image: devacrrepo.azurecr.io/cicd-runner:v1
      credentials:
        username: \${{ needs.getacrinfo.outputs.acruser }}
        password: \${{ needs.getacrinfo.outputs.acrtoken }}
    steps:
    - name: Check out code  
      uses: actions/checkout@v2
      with:
          ref: \${{ github.head_ref }}
    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with: 
          creds: \${{ secrets.TF_TERRATEST_CREDENTIALS }} 
    - name: 'tfvars download' 
      uses: actions/checkout@v2
      with: 
          repository: procter-gamble/terraform-terratest-metadata
          ref: main
          token: \${{ secrets.TF_GITHUB_PAT }}
          path: examples/full/vars
    - id:    terraform-upgrade-runtime
      name:  upgrade-runtime-action-metadata
      uses: ./examples/full/vars/utils/actions/upgrade-runtime
      with:
          TF_GITHUB_USER: \${{secrets.TF_GITHUB_USER}}
          TF_GITHUB_PAT: \${{secrets.TF_GITHUB_PAT}}
          TF_CLIENT_ID: \${{secrets.TF_CLIENT_ID}}  
          TF_CLIENT_SECRET: \${{secrets.TF_CLIENT_SECRET}}
          ARM_SUBSCRIPTION_ID: \${{secrets.ARM_SUBSCRIPTION_ID}}
    - name: send-status
      if: always()
      uses:  ./examples/full/vars/utils/actions/terratest-email-action
      with:
        JOB_NAME:  \${{ github.job }}
        REPO_NAME: \${{ github.repository }}
        JOB_STATUS: "\${{ job.status }}"
        WORKFLOW_NAME: "\${{ github.workflow }}"
        job_run_id: "\${{github.run_id}}"
        terraform_version: "\${{ steps.terraform-upgrade-runtime.outputs.terraform_version }}"
        azurerm_version:   "\${{  steps.terraform-upgrade-runtime.outputs.azurerm_version }}"
        terraformold_version: "\${{ steps.terraform-upgrade-runtime.outputs.terraformold_version }}"
        azurermold_version: "\${{ steps.terraform-upgrade-runtime.outputs.azurermold_version }}"
  `;

const wormEmoji = atob("IPCfkJsg");

const bugReport = `---
name: ${wormEmoji} Bug Report
about: Report a bug or issue with the Terraform module
title: "[BUG] <Short description>"
labels: bug
---

**Describe the bug**
A clear and concise description of what the bug is.

**Expected behavior**
A clear and concise description of what you expected to happen.

**Terraform Cloud (TFC) run URL**
URL of the run in Terraform Cloud, example: *https://app.terraform.io/app/pg-azure-prod/workspaces/<workspace_name>/runs/run-<id>*

**Terraform module version**
If executing locally, add the version of the module targeted in the source, example *git@github.com:procter-gamble/terraform-azure-vnet.git?ref=v4.5.1*

**Screenshots**
If executing locally, add screenshots to help explain your problem.

**Terraform Configuration Files (not necessary if TFC URL provided)**
If executing locally, add the \`.tf\` files code. Please redact any sensitive information.

\`\`\`hcl

# Paste your Terraform configuration here

\`\`\`
 `;

const rocketEmoji = atob("IPCfmoAg");

const featureRequest = `---
name: ${rocketEmoji} Feature Request
about: Suggest an idea or enhancement for the Terraform module
title: "[FEATURE] <Short description>"
labels: enhancement
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
 `;

const repositories = data.search.edges.map(
  (r) => `${r.node.url.replace("https://github.com/procter-gamble/", "")}`
);

const axios = require("axios");
const fs = require("fs");

const WEBHOOK_TOKEN = '';

class Axios {
  private api = "https://api.github.com/"
  private headers = { Authorization: `Bearer ${WEBHOOK_TOKEN}`, 'X-GitHub-Api-Version': '2022-11-28', "accept": "application/vnd.github.v3.repository+json" };
  private org = '';

  async fetchData(apiCall: any, params: any) {
    try {
      const response = await axios.get(apiCall, { headers: this.headers, ...params });
      return response.data;
    } catch (error: any) {
      console.error(`Fetching ${apiCall} failed in the repo ${params.repo}`);
    }
  }


  async updateData(apiCall: any, params: any) {
    try {
      const response = await axios.put(apiCall, params, { headers: this.headers, ...params });
      return response;
    } catch (error: any) {
      console.error(`Error with method put: `, error.response);
    }
  }

  async patchData(apiCall: any, params: any) {
    try {
      const response = await axios.patch(apiCall, params, { headers: this.headers, ...params });
      return response;
    } catch (error: any) {
      console.error(`Error: `, error.response.data, error.response.request.path);
    }
  }

  async postBranch(apiCall: any, params: any) {
    try {
      const response = await axios.post(apiCall, params, { headers: this.headers, ...params });
      return response;
    } catch (error: any) {
      console.error(`Error: `, error.response);
    }
  }

  async getRepoInfo(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}`, { repo });
  }

  async getRepoPullRequestIssues(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/issues`, { repo });
  }

  async getRepoBranches(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/branches`, { repo });
  }

  async getBranch(repo: string, name: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/branches/${name}`, { repo });
  }

  async readMe(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/readme`, { repo });
  }

  async actions(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/actions/workflows`, { repo });
  }

  async getCsvUsers() {
    return this.fetchData(`${this.api}repos/${this.org}/devx-github-index/contents/github_index.csv`, {});
  }

  async examplesFullFiles(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/contents/examples/full`, { repo });
  }

  async getfile(repo: string, fileFolder: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/contents/.github/${fileFolder}`, { repo });
  }

  async updateCodeOwners(repo: string, message: string, committer: any, content: string, sha: string | null = null, branch: string = "main") {
    return this.updateData(`${this.api}repos/${this.org}/${repo}/contents/.github/CODEOWNERS`, { message, committer, content, sha, branch });
  }

  async addActionTemplate(repo: string, message: string, file: string, content: string = "", sha: string | null = null, branch: string = "main") {
    return this.updateData(`${this.api}repos/${this.org}/${repo}/contents/.github/${file}`, { message, content, sha, branch });
  }

  async issueTemplate(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/contents/.github/ISSUE_TEMPLATE`, { repo });
  }

  async teamsRoles(team: string, repo: string) {
    return this.fetchData(`${this.api}orgs/${this.org}/teams/${team}/repos/${this.org}/${repo}`, { repo });
  }

  async patchDescription(repo: string, description: string) {
    return this.patchData(`${this.api}repos/${this.org}/${repo}`, { description });
  }

  async addTopic(repo: string, names: any) {
    return this.updateData(`${this.api}repos/${this.org}/${repo}/topics`, { names });
  }

  async getCommit(repo: string) {
    return this.fetchData(`${this.api}repos/${this.org}/${repo}/git/refs/heads/main`, { repo });
  }

  async createBrach(repo: string, ref: string, sha: string) {
    return this.postBranch(`${this.api}repos/${this.org}/${repo}/git/refs`, { ref, sha });
  }

  async pullrequest(repo: string, title: string, head: string, base: string, body: string) {
    return this.postBranch(`${this.api}repos/${this.org}/${repo}/pulls`, { title, head, base, body });
  }
}

/**
 * About & Topics
 */

async function aboutTopic(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.getRepoInfo(repo);
    checkAboutTopic(response.description, response.topics, repo);
  } catch (error: any) {
    console.error('Failed to fetch repository:', error.message);
  }
}

function checkAboutTopic(about: any, topics: any, repo: any) {
  const topic = "owner-azure-platform-engineering"
  if (about == null) {
    patchAbout(repo);
  }
  if (!topics.includes(topic)) {
    addTopic(repo, topic);
  }
}

async function patchAbout(repo: string) {
  const service = repo.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).slice(1).join(' ');
  const axiosCall = new Axios();
  const description = `This module handles ${service} in P&G Cloud environments.`;
  try {
    const response = await axiosCall.patchDescription(repo, description);
    console.log(`The API status is ${response.status}: ${response.statusText}. The description was successfully added in ${repo}.`);
  } catch (error) {
    console.error(`The description in the repository ${repo} could not be updated`);
  }
}

async function addTopic(repo: string, topic: string) {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.addTopic(repo, [topic]);
    console.log(`The API status is ${response.status}: ${response.statusText}. The topic was successfully added in ${repo}.`);
  } catch (error) {
    console.error(`The topic in the repository ${repo} could not be updated.`);
  }
}

/**
 * README
 */

async function readMe(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.readMe(repo);
    checkReadMe(response.size, repo)
  } catch (error) {
    console.error(`The repository ${repo} has no README`);
  }
}

function checkReadMe(size: any, repo: string) {
  if (size < 400) {
    console.log(`The repo ${repo} does not have an explicit README`)
  }
}

/**
 * Actions
 */

async function actions(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    //addActions(repo)
    const response = await axiosCall.actions(repo);
    //updateActions(repo);
    //checkActions(response, repo)
  } catch (error) {
    console.error(`The repository ${repo} has no Actions`);
    //addActions(repo)
  }
}

function checkActions(response: any, repo: string) {
  // if (response.total_count == 0) {
  //   console.log(response.total_count);
  //   addActions(repo);
  //   return;
  // }
  const actionsRequired = ["Auto Add Issues to Project", "PR", "docs", "Schedule", "terraform-upgrade-runtime", "terraform-upgrade-provider"];
  const actionsFound = response.workflows.map((workflow: any) => workflow.name);
  const missingActions = actionsRequired.filter((workflow: any) => !actionsFound.includes(workflow));
  console.log(repo);
  console.log(actionsFound + "\n");
  //addActions(repo, missingActions)
}

async function updateActions(repo: string, missingActions: string[] = []): Promise<any> {
  const axiosCall = new Axios();
  let actions = [{ content: addIssueToProject, path: "add-issue-to-project.yml" }, { content: docs, path: "documentation.yml" },
  { content: PR, path: "test.yml" }, { content: terraformUpgradeProvider, path: "terraform-upgrade-provider.yaml" },
  { content: terraformUpgradeRuntime, path: "terraform-upgrade-runtime.yaml" }, { content: schedule, path: "scheduled.yml" }];
  const path = "workflows/";

  const actionsSha = await Promise.all(actions.map(async (action: any) => {
    try {
      const responseSha = await axiosCall.getfile(repo, path + action.path);
      return { ...action, sha: responseSha.sha };
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error.status);
    }
  }));

  for (const action of actionsSha) {
    try {
      const message = `${action.path} file added`;
      const response = await axiosCall.addActionTemplate(repo, message, path + action.path, btoa(action.content), action.sha);
      console.log(`The API status is ${response.status}: ${response.statusText}.  ${repo}:`, response.data.content);
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error.status);
    }
  }
};

async function addActions(repo: string, missingActions: string[] = []): Promise<any> {
  const axiosCall = new Axios();
  const actions = [{ content: addIssueToProject, path: "add-issue-to-project.yml" }, { content: docs, path: "documentation.yml" },
    { content: PR, path: "test.yml" }, { content: terraformUpgradeProvider, path: "terraform-upgrade-provider.yaml" },
    { content: terraformUpgradeRuntime, path: "terraform-upgrade-runtime.yaml" }, { content: schedule, path: "scheduled.yml" }];
  const path = "workflows/";
  for (const action of actions) {
    try {
      const message = `${action.path} file added`;
      const response = await axiosCall.addActionTemplate(repo, message, path + action.path, btoa(action.content));
      console.log(`The API status is ${response.status}: ${response.statusText}. The action was successfully added in the module ${repo}.`);
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error.status);
    }
  }
}

/**
 * examples, full .tf files
 */

async function exampleFullFiles(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.examplesFullFiles(repo);
    checkExampleFullFiles(response, repo)
  } catch (error) {
    console.error(`The repository ${repo} has no examples/full .tf files`);
  }
}

function checkExampleFullFiles(response: any, repo: string) {
  const filesRequired = ["example.tfvars", "main.tf", "outputs.tf", "provider.tf", "variables.tf"];
  const filesFound = response.map((file: any) => file.name);
  const missingFiles = filesRequired.filter((file: any) => !filesFound.includes(file));
  console.log(repo)
  console.log(missingFiles + "\n")
}

/**
 * CODEOWNERS
 */

async function codeOwners(repo: string): Promise<any> {
  const content = "KiBAcHJvY3Rlci1nYW1ibGUvYXp1cmUtcGxhdGZvcm0tZW5naW5lZXJpbmct\nYWRtaW5z\n";
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.getfile(repo, "CODEOWNERS");
    checkCodeOwners(response, repo, content)
  } catch (error) {
    console.error(`The repository ${repo} does not have a CODEOWNERS file`);
    updateCodeOwners(repo, content);
  }
}

function checkCodeOwners(response: any, repo: string, correctContent: string) {
  if (response.content != correctContent)
    updateCodeOwners(repo, correctContent, response.sha, "Update");
}

async function updateCodeOwners(repo: string, content: string, sha: string | null = null, action: string = "Add") {
  const axiosCall = new Axios();
  const message = `${action} CODEOWNERS`;
  const committer = {
    name: 'eph96PG',
    email: 'perez.e@pg.com'
  };
  try {
    const response = await axiosCall.updateCodeOwners(repo, message, committer, content, sha);
    console.log(response.status, response.statusText, response.data);
  } catch (error) {
    console.error(`The file CODEOWENER in the repository ${repo} could not be updated without a PR`);
    //pullRequestUpdateCodeOwners(repo, message, committer, content)
  }
}

// async function pullRequestUpdateCodeOwners(repo: string, message: string, committer: any, content: string) {
//   const axiosCall = new Axios();
//   const nameNewBranch = "add-CODEOWNERS";
//   const base = "main";
//   const body = 'This pull request adds a CODEOWNERS file to the repository.';
//   try {
//     const mainSha = await axiosCall.getCommit(repo);
//     await axiosCall.createBrach(repo, `refs/heads/${nameNewBranch}`, mainSha.object.sha);
//     await axiosCall.updateCodeOwners(repo, message, committer, content, mainSha, nameNewBranch);
//     const response = await axiosCall.pullrequest(repo, message, nameNewBranch, base, body);
//     console.log(response);
//   } catch (error) {
//     console.error(`The file CODEOWENER in the repository ${repo} could not be updated through a PR`);
//   }
// }

/**
 * ISSUE_TEMPLATE
 */

async function issueTemplate(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.issueTemplate(repo);
    checkIssueTemplate(response, repo)
    //updateIssueTemplate(repo)
  } catch (error) {
    console.error(`The repository ${repo} does not have an ISSUE_TEMPLATE file`);
  }
}

function checkIssueTemplate(response: any, repo: string) {
  const filesRequired = ["1-bug_report.md", "2-feature_request.md"];
  const filesFound = response.map((file: any) => file.name);
  const missingFiles = filesRequired.filter((file: any) => !filesFound.includes(file));
  if (missingFiles.length != 0)
    console.log(repo + "\n" + "Files found: " + filesFound + "\n" + "Files missing: " + missingFiles + "\n");
}

async function updateIssueTemplate(repo: string): Promise<any> {
  const axiosCall = new Axios();
  let templates = [{ content: bugReport, path: "1-bug_report.md" }, { content: featureRequest, path: "2-feature_request.md" }];
  const path = "ISSUE_TEMPLATE/";

  const templatesSha = await Promise.all(templates.map(async (template: any) => {
    try {
      const responseSha = await axiosCall.getfile(repo, path + template.path);
      return { ...template, sha: responseSha.sha };
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error.status);
      addIssueTemplate(repo);
    }
  }));

  for (const template of templatesSha) {
    try {
      const message = `${template.path} file updated`;
      const response = await axiosCall.addActionTemplate(repo, message, path + template.path, btoa(template.content), template.sha);
      console.log(`The API status is ${response.status}: ${response.statusText}. The ISSUE_TEMPLATE was successfully updated to the module ${repo}.`);
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error);
    }
  }
};

async function addIssueTemplate(repo: string): Promise<any> {
  const axiosCall = new Axios();
  const templates = [{ content: bugReport, path: "1-bug_report.md" }, { content: featureRequest, path: "2-feature_request.md" }];
  const path = "ISSUE_TEMPLATE/";

  for (const template of templates) {
    try {
      const message = `${template.path} file added`;
      const response = await axiosCall.addActionTemplate(repo, message, path + template.path, btoa(template.content));
      console.log(`The API status is ${response.status}: ${response.statusText}. The ISSUE_TEMPLATE was successfully added to the module ${repo}:`, response.data.content.url);
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error);
    }
  }
}

/**
 * Creates .csv files
 */

const fileBranches = `${__dirname}/repo-branches.csv`;
fs.writeFileSync(fileBranches, "");
fs.appendFileSync(fileBranches, "repository, dateUpdated, state, userPG, userGithub, name, url\n");

async function csvBranches(repo: string, data: any) {
  fs.appendFileSync(fileBranches, `${repo},`);
  fs.appendFileSync(fileBranches, `${data.state},`);
  fs.appendFileSync(fileBranches, `${data.dateUpdated},`);
  fs.appendFileSync(fileBranches, `${data.userPG},`);
  fs.appendFileSync(fileBranches, `${data.userGithub},`);
  fs.appendFileSync(fileBranches, `${data.name},`);
  fs.appendFileSync(fileBranches, `${data.url}\n`);
}

const filePullRequestsIssues = `${__dirname}/repo-pullRequests-issues.csv`;
fs.writeFileSync(filePullRequestsIssues, "");
fs.appendFileSync(filePullRequestsIssues, "repository, type, dateUpdated, title, url\n");

async function csvPullRequestsIssues(repo: string, data: any) {
  fs.appendFileSync(filePullRequestsIssues, `${repo},`);
  fs.appendFileSync(filePullRequestsIssues, `${data.type},`);
  fs.appendFileSync(filePullRequestsIssues, `${data.dateUpdated},`);
  fs.appendFileSync(filePullRequestsIssues, `${data.title},`);
  fs.appendFileSync(filePullRequestsIssues, `${data.url}\n`);
}

/**
 * Issues & PRs
 */

async function listIssuesPullRequests(repo: string): Promise<any> {
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.getRepoPullRequestIssues(repo);
    response.map((element: any) => {
      if (element.pull_request) {
        csvPullRequestsIssues(repo, { type: "Pull resquest", title: element.title, dateUpdated: element.updated_at, url: element.html_url });
        return
      }
      csvPullRequestsIssues(repo, { type: "Issue", title: element.title, dateUpdated: element.updated_at, url: element.html_url })
    });
  } catch (error) {
    console.error(`The repository ${repo}`);
  }
}
/**
 * Direct Access Role
 */

 async function directAccessRole(repo: string): Promise<any> {
  const axiosCall = new Axios();
  const teams = ["azure-platform-engineering-developers", "azure-platform-engineering-admins"];
  await Promise.all(teams.map(async (team: any) => {
    try {
      const responseRole = await axiosCall.teamsRoles(team, repo);
      console.log(repo,team, "\n", responseRole.role_name, "\n")
    } catch (error: any) {
      console.error(`The repository ${repo} ...`, error.message, error.status);
    }
  }));
}

// function checkdirectAccessRole(response: any, repo: string) {
//   const filesRequired = ["1-bug_report.md", "2-feature_request.md"];
//   const filesFound = response.map((file: any) => file.name);
//   const missingFiles = filesRequired.filter((file: any) => !filesFound.includes(file));
//   if (missingFiles.length != 0)
//     console.log(repo + "\n" + "Files found: " + filesFound + "\n" + "Files missing: " + missingFiles + "\n");
// }

/**
 * Branches
 */

const get3MonthsAgo = () => {
  const now = new Date();
  const monthAgo = new Date(now.getFullYear(), now.getMonth() - 3, now.getDate());
  return monthAgo.toISOString();
};

async function endodeCsv(): Promise<any> {
  const usersPG = [];
  const axiosCall = new Axios();
  try {
    const response = await axiosCall.getCsvUsers();
    const content = atob(response.content);
    const rawUsers = content.split("\n").slice(1);
    for (let element of rawUsers) {
      usersPG.push({
        pgUser: element.split(",")[0],
        gitUsernames: element.split(",")[element.split(",").length - 1] == '' ?
          element.split(",").slice(1, -1) : element.split(",").slice(1)
      })
    }
    console.log(usersPG)
    return usersPG;
  } catch (error) {
    console.error(`The .csv from the Devx repo could not be retrieved`);
  }
}

async function listBranches(repo: string, users: any): Promise<any> {
  const axiosCall = new Axios();
  let userPG: string;
  try {
    const response = await axiosCall.getRepoBranches(repo);
    response.map(async (element: any) => {
      const branch = await axiosCall.getBranch(repo, element.name);
      const state = branch.commit.commit.author.date < get3MonthsAgo() ? "Stale" : "Active";
      if (branch.commit.author != null) {
        for await (let userObject of users) {
          if (userObject.gitUsernames.includes(branch.commit.author.login)) {
            userPG = userObject.pgUser;
          }
        }
        return csvBranches(repo,
          { state: state, dateUpdated: branch.commit.commit.author.date, userPG: userPG, userGithub: branch.commit.author.login, name: branch.name, url: branch._links.html })
      } else {
        return csvBranches(repo,
          { state: state, dateUpdated: branch.commit.commit.author.date, userPG: null, userGithub: null, name: branch.name, url: branch._links.html })
      }
    });
  } catch (error) {
    console.error(`The repository ${repo}`);
  }
}

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function repoDetails() {
  //const users = await endodeCsv(); // UNCOMMENT WHEN listBranches() IS USED
  for (const repo of repositories) {
    //await directAccessRole(repo);
    //await sleep(10000);
    //await aboutTopic(repo);
    //await readMe(repo);
    //await actions(repo);
    //await exampleFullFiles(repo);
    //await codeOwners(repo);
    //await issueTemplate(repo)
    //listIssuesPullRequests(repo);
    //listBranches(repo, users);
  }
}

repoDetails();